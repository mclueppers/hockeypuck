# Sample haproxy configuration for keyservers
# (c) Martin Dobrev, Andrew Gallagher 2023

# This file is optimised for hockeypuck's docker-compose/standalone deployment, however it is
# applicable to other deployments with minor edits to backend definitions and file paths.
#
# To facilitate portability, it has been parameterised using envsubst notation: ${...}
# These parameters are populated by the docker-compose/standalone scripts.

# FQDN                  the FQDN of this server, note that aliases must also be configured
# CERTBOT_HOST_PORT     backend for ACME requests, in the form `host:port`
# PROMETHEUS_HOST_PORT  backend for prometheus monitoring, in the form `host:port`
# KEYSERVER_HOST_PORT   backend for the keyserver, in the form `host:port`
# HAP_CONF_DIR          location of config files
#                       normally /etc/haproxy for baremetal, or /usr/local/etc/haproxy for docker
#                       it must have a subdir lists/ containing the blacklist.list and whitelist.list files
# HAP_CACHE_DIR         persistent state store, e.g. tor_exit_relays.list, this must be updated externally
# HAP_CERT_DIR          parent directory for SSL/TLS certificates
#                       it must have a subdirectory called FQDN containing the certs
#                       e.g. for letsencrypt this will be `/etc/letsencrypt/live`
# HAP_DHPARAM_FILE      Diffie-Hellman parameters for SSL/TLS

global
    # Map threads to individual CPU cores
    cpu-map auto:1/1-2 0-1

    # generated 2022-10-15, Mozilla Guideline v5.6, HAProxy 2.4, OpenSSL 3.0.2, intermediate configuration
    # https://ssl-config.mozilla.org/#server=haproxy&version=2.4&config=intermediate&openssl=3.0.2&guideline=5.6
    ssl-default-bind-ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384
    ssl-default-bind-ciphersuites TLS_AES_128_GCM_SHA256:TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256
    ssl-default-bind-options prefer-client-ciphers no-sslv3 no-tlsv10 no-tlsv11 no-tls-tickets

    ssl-default-server-ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384
    ssl-default-server-ciphersuites TLS_AES_128_GCM_SHA256:TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256
    ssl-default-server-options no-sslv3 no-tlsv10 no-tlsv11 no-tls-tickets

    ssl-dh-param-file ${HAP_DHPARAM_FILE}

    log stdout format raw local0

    # Allow maximum of 200 000 connections
    maxconn 200000

    tune.comp.maxlevel  5
    maxcompcpuusage     98

    # lower the record size to improve Time to First Byte (TTFB)
    tune.ssl.maxrecord  1419

    # Number of threads per process
    nbthread 12

    # Tune SSL cache size
    tune.ssl.cachesize 500000
    # Tune DH params
    tune.ssl.default-dh-param 4096

    # Allow local admin socket
    stats socket ${HAP_CACHE_DIR}/haproxy.admin.sock mode 660 level admin expose-fd listeners
    stats timeout 30s

    server-state-file ${HAP_CACHE_DIR}/server-state

defaults
    load-server-state-from-file global

    option dontlognull
    option http-server-close
    option splice-response
    option clitcpka
    option srvtcpka
    option tcp-smart-accept
    option tcp-smart-connect
    option contstats
    retries 3

    timeout http-request    5s
    timeout http-keep-alive 5s
    timeout connect         5s
    timeout client          60s
    timeout client-fin      60s
    timeout tunnel          40m         # timeout to use with WebSocket and CONNECT
    timeout server          150s
    timeout tarpit          15s
    timeout queue           10s

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Stick Tables
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
backend st_global_ddos
    # Stick Table Definitions
    #  - conn_cur: count active connections
    #  - conn_rate(10s): average incoming connection rate over 10 seconds
    #  - http_err_rate(60s): Monitors the number of errors generated by an IP over a period of 60 seconds
    #  - http_req_rate(60s): Monitors the number of request sent by an IP over a period of 60 seconds
    stick-table type ip size 2m expire 30s store conn_cur,conn_rate(10s),http_req_rate(60s),http_err_rate(60s)

backend st_tor_request_rate
    stick-table type string len 32 size 10 expire 24h store conn_cur,conn_rate(10s),http_req_rate(10s),http_err_rate(10s)

backend st_tor_24h_ban
    stick-table type ip size 1m expire 24h store gpc0

backend st_tor_1month_ban
    stick-table type ip size 1m expire 30d store gpc0


# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Frontends
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# Frontend to handle HTTP and HTTPS requests
frontend fe_http_s_balancer
    bind *:443
    bind *:11371
    mode tcp

    acl blacklisted src -f ${HAP_CONF_DIR}/lists/blacklist.list

    tcp-request inspect-delay 5s

    # option tcplog
    # log stdout format raw local2
    # log-format "%ci:%cp [%t] %ft %b/%s %Tw/%Tc/%Tt %B %ts %ac/%fc/%bc/%sc/%rc %sq/%bq"

    tcp-request content reject if blacklisted
    tcp-request content accept if HTTP
    tcp-request content accept if { req.ssl_hello_type 1 }

    use_backend be_forward_http if HTTP
    use_backend be_forward_https if { req.ssl_hello_type 1 }

    default_backend be_tarpit

# Frontend to handle the actual HTTP requests
frontend fe_http_handler
    bind :80
    bind :::80

    # Loopback interface
    bind abns@loopback-http accept-proxy
    bind abns@loopback-https accept-proxy ssl crt ${HAP_CERT_DIR}/${FQDN}/fullchain.pem alpn h2,http/1.1

    mode http

    # Instance is not stopping
    acl stopping stopping eq 1

    # Match ACME challenge
    acl acme_challenge      path_beg /.well-known/acme-challenge/

    # Check for valid vhost names
    acl keyserver_host      hdr_beg(host) -i ${FQDN}
    #acl keyserver_host      hdr_beg(host) -i ${ALIAS_FQDN_1}
    #acl keyserver_host      hdr_beg(host) -i ${ALIAS_FQDN_2}

    # keyserver settings
    acl get_pks_lookup         path_beg      /pks/lookup
    acl post_pks_add           path_beg      /pks/add
    acl post_pks_delete        path_beg      /pks/delete
    acl post_pks_hashquery     path_beg      /pks/hashquery
    acl post_pks_replace       path_beg      /pks/replace
    acl pks_stats_query        query         -i -m sub stats
    acl get_prometheus         path_beg      /monitoring/prometheus
    acl get_webroot            path_beg      /

    # Tor exit nodes
    # These should be refreshed on a schedule using an external script.
    # After updating, haproxy should be refreshed using the graceful method described at
    # https://www.haproxy.com/blog/hitless-reloads-with-haproxy-howto/
    acl is_tor_exit_relay   src -f ${HAP_CACHE_DIR}/tor_exit_relays.list

    # .well-known/security.txt settings
    acl well_known_sec      path_beg -i /security.txt
    acl well_known_sec      path_beg -i /.well-known/security.txt

    # Check if requestor is blacklisted
    acl blacklisted         src -f ${HAP_CONF_DIR}/lists/blacklist.list
    tcp-request connection  reject if blacklisted

    capture request header Host len 253
    capture request header X-REQ-ID len 32
    capture request header X-Forwarded-For len 64
    capture request header Accept-Language len 64
    capture request header Referer len 64
    capture request header User-Agent len 128
    capture request header Content-Length len 10
    capture request header X-Haproxy-Secure len 3
    capture request header X-Haproxy-ACL len 256
    capture request header X-Haproxy-TARPIT len 256

    # Add the X-Forwarded-For header
    option forwardfor except 127.0.0.0/8

    # ~~~ DDoS protection ~~~
    # HAproxy tracks client IPs into a global stick table. Each IP is
    # stored for a limited amount of time, with several counters attached
    # to it. When a new connection comes in, the stick table is evaluated
    # to verify that the new connection from this client is allowed to
    # continue.
    tcp-request inspect-delay 5s

    # Enable tracking of counters for ip in the default stick-table, using CF-Connecting-IP or X-Forwarded-For
    acl HAS_CF_CONNECTING_IP hdr_cnt(CF-Connecting-IP) eq 1
    acl HAS_X_FORWARDED_FOR hdr_cnt(X-Forwarded-For) eq 1

    # Track requests from CF-Connecting-IP or X-Forwarded-For header, or source IP into the global ddos stick-table
    tcp-request content track-sc0 hdr_ip(CF-Connecting-IP,-1) table st_global_ddos if HTTP HAS_CF_CONNECTING_IP !is_tor_exit_relay
    tcp-request content track-sc0 hdr_ip(X-Forwarded-For,-1) table st_global_ddos if HTTP !HAS_CF_CONNECTING_IP HAS_X_FORWARDED_FOR !is_tor_exit_relay
    tcp-request content track-sc0 src table st_global_ddos if HTTP !HAS_CF_CONNECTING_IP !HAS_X_FORWARDED_FOR !is_tor_exit_relay

    # Generic health monitor for umbrella LBs in enterprise deployments.
    acl BACKEND_DEAD nbsrv(be_keyserver) lt 1
    monitor-uri /_healthz
    monitor fail if BACKEND_DEAD

    # Store Host header to construct Via response for keyserver backend
    http-request set-var(txn.serverName) req.hdr(host) if keyserver_host

    # TARPIT the new connection if the client already has 80 opened
    http-request tarpit if { src_conn_cur(st_global_ddos) ge 80 } !is_tor_exit_relay

    # TARPIT the new connection if the client has opened more than 40 connections in 3 seconds
    http-request tarpit if { src_conn_rate(st_global_ddos) ge 40 } !is_tor_exit_relay

    # TARPIT the connection if the client has passed the HTTP error rate (10s)
    http-request tarpit if { sc0_http_err_rate(st_global_ddos) gt 20 } !is_tor_exit_relay

    # TARPIT the connection if the client has passed the HTTP request rate (10s)
    http-request tarpit if { sc0_http_req_rate(st_global_ddos) gt 100 } !is_tor_exit_relay

    # For country blocking and blacklists, if no CF-Connecting-IP is present, use the last value of X-Forwarded-For
    # and set the CF-Connecting-IP header to it
    acl HAS_CF_CONNECTING_IP req.fhdr(CF-Connecting-IP) -m found
    http-request set-header CF-Connecting-IP %[req.hdr_ip(X-Forwarded-For,-1)] if !HAS_CF_CONNECTING_IP HAS_X_FORWARDED_FOR
    http-request set-header CF-Connecting-IP src if !HAS_CF_CONNECTING_IP !HAS_X_FORWARDED_FOR

    # Whitelisting options
    http-request allow if { req.hdr_ip(CF-Connecting-IP,-1) -f ${HAP_CONF_DIR}/lists/whitelist.list }

    # ~ Tor exit relay nodes rules ~
    # Track request and connection rate for Tor exit nodes to POST /pks/add
    http-request track-sc1 str(TOR_EXIT_RELAY) table st_tor_request_rate if is_tor_exit_relay keyserver_host post_pks_add METH_POST

    # Apply rate limiting for Tor exit nodes
    acl tor_request_rate_limit sc1_http_req_rate(st_tor_request_rate) gt 2
    acl tor_conn_count         sc1_conn_cur(st_tor_request_rate) gt 1
    acl tor_conn_rate_limit    sc1_conn_rate(st_tor_request_rate) gt 1

    # Check if the IP is already banned
    acl tor_ip_24h_banned      sc2_get_gpc0(st_tor_24h_ban) gt 0
    acl tor_ip_1month_banned   sc2_get_gpc0(st_tor_1month_ban) gt 0
    
    # Block requests if the IP is on the 24h ban list or 1-month ban list
    http-request deny deny_status 429 hdr Denial-Reason "This Tor exit relay was used in DDoS attack on this service. Do not make any further requests. This will olny make things worse." if is_tor_exit_relay tor_ip_24h_banned
    http-request deny deny_status 429 hdr Denial-Reason "This Tor exit relay is a repeat offender used in DDoS attack on this service. Hard ban enforced" if is_tor_exit_relay tor_ip_1month_banned

    # Increment the gpc0 counter in the 1-month ban stick table if the IP attempts another request within the 24h or 1-month ban period
    http-request track-sc2 hdr_ip(CF-Connecting-IP,-1) table st_tor_1month_ban if is_tor_exit_relay tor_ip_24h_banned
    http-request track-sc2 hdr_ip(CF-Connecting-IP,-1) table st_tor_1month_ban if is_tor_exit_relay tor_ip_1month_banned

    # Block requests if either the connection rate or request rate limits are exceeded
    # Increment the gpc0 counter in the 24h ban stick table if the request is blocked
    http-request set-var(txn.ratelimited) str(RATE-LIMITED) if is_tor_exit_relay tor_request_rate_limit !tor_ip_24h_banned
    http-request set-var(txn.ratelimited) str(RATE-LIMITED) if is_tor_exit_relay tor_conn_rate_limit !tor_ip_24h_banned
    http-request set-var(txn.ratelimited) str(RATE-LIMITED) if is_tor_exit_relay tor_conn_count !tor_ip_24h_banned
    http-request capture var(txn.ratelimited) len 12        if is_tor_exit_relay tor_request_rate_limit !tor_ip_24h_banned
    http-request capture var(txn.ratelimited) len 12        if is_tor_exit_relay tor_conn_rate_limit !tor_ip_24h_banned
    http-request capture var(txn.ratelimited) len 12        if is_tor_exit_relay tor_conn_count !tor_ip_24h_banned

    # Check if the request was rate limited
    acl tor_request_rate_limited var(txn.ratelimited) -m found

    # Block requests if the request was rate limited and increment the gpc0 counter in the 24h ban stick table
    http-request deny deny_status 429 hdr Denial-Reason "Exceeded rate limit. You had: %[sc1_conn_cur(st_tor_request_rate)] established connections, %[sc1_conn_rate(st_tor_request_rate)] connection rate and %[sc1_http_req_rate(st_tor_request_rate)] requests." if tor_request_rate_limited
    http-request track-sc2 hdr_ip(CF-Connecting-IP,-1) table st_tor_24h_ban if tor_request_rate_limited
    # ~ End of Tor exit relay nodes rules ~
    
    # Options
    option httplog
    option http-server-close
    option dontlognull

    log stdout format raw local1
    log-format "%ci:%cp [%t] %ft %b/%s %Tq/%Tw/%Tc/%Tr/%Tt %ST %U/%B %CC %CS %tsc %ac/%fc/%bc/%sc/%rc %sq/%bq %hr %hs %{+Q}r"

    # X-Forward- settings
    http-request    set-header X-Forwarded-Proto http  if !{ ssl_fc }
    http-request    set-header X-Forwarded-Proto https if { ssl_fc }
    http-request    set-header X-Forwarded-Host  %[req.hdr(host)]

    # HSTS response header
    http-response   set-header Strict-Transport-Security "max-age=63072000; includeSubDomains; preload" if { ssl_fc }

    # Secure response cookies
    http-response   replace-header Set-Cookie ^((?:.(?!\ [Ss]ecure))*)$ \1;\ Secure if { ssl_fc }

    # # Backend routing
    use_backend be_acme_challenge  if acme_challenge
    use_backend be_prometheus      if get_prometheus

    # Fetch stats from the primary Hockeypuck instance
    use_backend be_keyserver_primary if keyserver_host get_pks_lookup pks_stats_query METH_GET
    # Fetch recon hash queries from the primary Hockeypuck instance
    use_backend be_keyserver_primary if post_pks_hashquery METH_POST
    # Use cluster backend for all other requests
    use_backend be_keyserver         if keyserver_host get_pks_lookup METH_GET
    use_backend be_keyserver         if keyserver_host post_pks_delete METH_POST
    use_backend be_keyserver         if keyserver_host post_pks_replace METH_POST
    # Allow POST /pks/add requests from all IPs to the primary Hockeypuck instance
    use_backend be_keyserver_primary if keyserver_host post_pks_add METH_POST
    # Completely block POST /pks/add requests from Tor exit nodes
    #use_backend be_keyserver_primary if keyserver_host post_pks_add !is_tor_exit_relay METH_POST
    #use_backend be_tarpit            if keyserver_host post_pks_add is_tor_exit_relay METH_POST
    use_backend be_keyserver         if keyserver_host get_webroot !post_pks_add !post_pks_hashquery !post_pks_delete !post_pks_replace METH_GET

    default_backend be_tarpit

# Frontend to export stats to prometheus
frontend fe_prometheus
    bind :8405
    http-request use-service prometheus-exporter
    no log

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Backends
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# Backend to forward HTTP requests
backend be_forward_http
    mode tcp
    description Forward HTTP requests to the HTTP frontend
    server srv_http abns@loopback-http send-proxy-v2

# Backend to forward HTTPS requests
backend be_forward_https
    mode tcp
    description Forward HTTPS requests to the HTTP frontend
    server srv_https abns@loopback-https send-proxy-v2

# Backend to serve ACME HTTP-01 challenge requests
backend be_acme_challenge
    mode http
    description certbot ACME HTTP-1 validation endpoint
    server certbot ${CERTBOT_HOST_PORT} maxconn 20

# Backend to tarpit connections
backend be_tarpit
    mode http
    
    stick-table type ip size 1m expire 1m store conn_cur,conn_rate(10s),http_req_rate(10s)

    http-request silent-drop if { src_conn_cur gt 10 }
    http-request silent-drop if { src_conn_cur gt 5 } { src_http_req_rate gt 10 }

    http-request tarpit

# Backend to prometheus web interface
backend be_prometheus
    mode http

    # Set the Via header
    http-response set-header Via "1.1 %[var(txn.serverName)] (Hockey stick)" if { var(txn.serverName) -m found }

    # ~~ URL rewriting rules ~~
    http-request replace-path ^/monitoring/prometheus/(.*) /\1
    # ~~ End of URL rewriting rules ~~

    server prometheus ${PROMETHEUS_HOST_PORT} maxconn 20

# Keyserver backends
backend be_keyserver_primary
    mode http

    # Set the Via header
    http-response set-header Via "1.1 %[var(txn.serverName)] (Hockey stick)" if { var(txn.serverName) -m found }

    # ~~ URL rewriting rules ~~
    http-request replace-path ^/stats([^\ ]*) /pks/lookup?op=stats\1
    http-request replace-path ^/s/(.*)        /pks/lookup?op=index&options=mr&search=\1
    http-request replace-path ^/search/(.*)   /pks/lookup?op=index&options=mr&search=\1
    http-request replace-path ^/g/(.*)        /pks/lookup?op=get&search=\1
    http-request replace-path ^/get/(.*)      /pks/lookup?op=get&search=\1
    http-request replace-path ^/d/(.*)        /pks/lookup?op=get&options=mr&search=\1
    http-request replace-path ^/download/(.*) /pks/lookup?op=get&options=mr&search=\1
    # ~~ End of URL rewriting rules ~~

    option httpchk
    http-check send meth GET uri /pks/lookup?op=stats hdr Host ${FQDN}
    http-check expect status 200
    http-check send-state

    server srv_hockeypuck ${KEYSERVER_HOST_PORT} check inter 5s on-error mark-down rise 2 fall 3

backend be_keyserver
    mode http

    # Set the Via header
    http-response set-header Via "1.1 %[var(txn.serverName)] (Hockey stick)" if { var(txn.serverName) -m found }

    # ~~ URL rewriting rules ~~
    http-request replace-path ^/stats([^\ ]*) /pks/lookup?op=stats\1
    http-request replace-path ^/s/(.*)        /pks/lookup?op=index&options=mr&search=\1
    http-request replace-path ^/search/(.*)   /pks/lookup?op=index&options=mr&search=\1
    http-request replace-path ^/g/(.*)        /pks/lookup?op=get&search=\1
    http-request replace-path ^/get/(.*)      /pks/lookup?op=get&search=\1
    http-request replace-path ^/d/(.*)        /pks/lookup?op=get&options=mr&search=\1
    http-request replace-path ^/download/(.*) /pks/lookup?op=get&options=mr&search=\1
    # ~~ End of URL rewriting rules ~~

    option httpchk
    http-check send meth GET uri /pks/lookup?op=stats hdr Host ${FQDN}
    http-check expect status 200
    http-check send-state

    server srv_keyserver ${KEYSERVER_HOST_PORT} check inter 5s on-error mark-down rise 2 fall 3
    # Uncomment, duplicate, and edit the following to load-balance across multiple stacks
    #server srv_keyserver_remote ${REMOTE_KEYSERVER_HOST_PORT} backup check inter 5s on-error mark-down rise 2 fall 3
