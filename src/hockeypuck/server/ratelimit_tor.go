/*
   Hockeypuck - OpenPGP key server
   Copyright (C) 2012-2025 Hockeypuck Contributors

   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU Affero General Public License as published by
   the Free Software Foundation, version 3.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU Affero General Public License for more details.

   You should have received a copy of the GNU Affero General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

package server

import (
	"bufio"
	"context"
	"io"
	"net"
	"net/http"
	"os"
	"strings"
	"time"

	log "github.com/sirupsen/logrus"
)

// startTorExitUpdater starts the background Tor exit node list updater
func (rl *RateLimiter) startTorExitUpdater() {
	// Load initial list from cache if it exists
	rl.loadTorExitCache()

	// Start periodic updates
	updateTicker := time.NewTicker(rl.config.Tor.UpdateInterval)

	go func() {
		// Update immediately on start (after cache load)
		rl.updateTorExitList()

		for {
			select {
			case <-updateTicker.C:
				rl.updateTorExitList()
			case <-rl.ctx.Done():
				updateTicker.Stop()
				return
			}
		}
	}()
}

// updateTorExitList fetches and updates the Tor exit node list
func (rl *RateLimiter) updateTorExitList() {
	log.Debug("Updating Tor exit node list")

	client := &http.Client{
		Timeout: 30 * time.Second,
	}

	resp, err := client.Get(rl.config.Tor.ExitNodeListURL)
	if err != nil {
		log.WithError(err).Error("Failed to fetch Tor exit node list")
		return
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		log.WithField("status_code", resp.StatusCode).Error("Failed to fetch Tor exit node list")
		return
	}

	// Parse the response
	newExits, err := rl.parseTorExitList(resp.Body)
	if err != nil {
		log.WithError(err).Error("Failed to parse Tor exit node list")
		return
	}

	// Update storage based on configuration
	if rl.config.Tor.UseBackendStorage {
		// Store in backend (Redis/memory backend)
		ctx := context.Background()
		if err := rl.backend.StoreTorExits(ctx, newExits); err != nil {
			log.WithError(err).Error("Failed to store Tor exit list in backend")
		} else {
			log.WithField("tor_exits", len(newExits)).Info("Updated Tor exit node list in backend")
		}
	} else {
		// Store in local memory and file cache (original behavior)
		rl.mu.Lock()
		rl.torExits = newExits
		rl.mu.Unlock()

		// Save to cache file
		if err := rl.saveTorExitCache(newExits); err != nil {
			log.WithError(err).Error("Failed to save Tor exit node cache")
		}

		log.WithField("tor_exits", len(newExits)).Info("Updated Tor exit node list")
	}
}

// parseTorExitList parses the Tor exit node list from dan.me.uk
func (rl *RateLimiter) parseTorExitList(r io.Reader) (map[string]bool, error) {
	exits := make(map[string]bool)
	scanner := bufio.NewScanner(r)

	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())

		// Skip empty lines and comments
		if line == "" || strings.HasPrefix(line, "#") {
			continue
		}

		// Validate IP address
		if ip := net.ParseIP(line); ip != nil {
			exits[line] = true
		}
	}

	if err := scanner.Err(); err != nil {
		return nil, err
	}

	return exits, nil
}

// loadTorExitCache loads Tor exit nodes from cache file or backend
func (rl *RateLimiter) loadTorExitCache() {
	if rl.config.Tor.UseBackendStorage {
		// Load from backend
		ctx := context.Background()
		exits, err := rl.backend.LoadTorExits(ctx)
		if err != nil {
			log.WithError(err).Error("Failed to load Tor exit list from backend")
			return
		}

		if len(exits) > 0 {
			// Update local cache for performance
			rl.mu.Lock()
			rl.torExits = exits
			rl.mu.Unlock()

			log.WithField("tor_exits", len(exits)).Info("Loaded Tor exit nodes from backend")
		}
		return
	}

	// Original file-based loading
	if rl.config.Tor.CacheFilePath == "" {
		return
	}

	file, err := os.Open(rl.config.Tor.CacheFilePath)
	if err != nil {
		if !os.IsNotExist(err) {
			log.WithError(err).Error("Failed to open Tor exit cache file")
		}
		return
	}
	defer file.Close()

	exits, err := rl.parseTorExitList(file)
	if err != nil {
		log.WithError(err).Error("Failed to parse Tor exit cache file")
		return
	}

	rl.mu.Lock()
	rl.torExits = exits
	rl.mu.Unlock()

	log.WithField("tor_exits", len(exits)).Info("Loaded Tor exit nodes from cache")
}

// saveTorExitCache saves Tor exit nodes to cache file
func (rl *RateLimiter) saveTorExitCache(exits map[string]bool) error {
	if rl.config.Tor.CacheFilePath == "" {
		return nil
	}

	file, err := os.Create(rl.config.Tor.CacheFilePath)
	if err != nil {
		return err
	}
	defer file.Close()

	// Write header comment
	if _, err := file.WriteString("# Tor exit node list cache\n"); err != nil {
		return err
	}
	if _, err := file.WriteString("# Generated by Hockeypuck rate limiter\n"); err != nil {
		return err
	}
	if _, err := file.WriteString("# " + time.Now().Format(time.RFC3339) + "\n"); err != nil {
		return err
	}

	// Write IP addresses
	for ip := range exits {
		if _, err := file.WriteString(ip + "\n"); err != nil {
			return err
		}
	}

	return nil
}

// GetTorExitStats returns statistics about Tor exit nodes
func (rl *RateLimiter) GetTorExitStats() map[string]interface{} {
	stats := map[string]interface{}{
		"enabled":             rl.config.Tor.Enabled,
		"update_url":          rl.config.Tor.ExitNodeListURL,
		"cache_file":          rl.config.Tor.CacheFilePath,
		"update_interval":     rl.config.Tor.UpdateInterval.String(),
		"use_backend_storage": rl.config.Tor.UseBackendStorage,
	}

	if rl.config.Tor.UseBackendStorage {
		// Get stats from backend
		ctx := context.Background()
		if backendStats, err := rl.backend.GetTorStats(ctx); err == nil {
			stats["count"] = backendStats.Count
			stats["last_updated"] = backendStats.LastUpdated
			stats["backend_ttl"] = backendStats.TTL.String()
		} else {
			log.WithError(err).Error("Failed to get Tor stats from backend")
			stats["count"] = 0
			stats["error"] = "Failed to get backend stats"
		}
	} else {
		// Get stats from local memory
		rl.mu.RLock()
		count := len(rl.torExits)
		rl.mu.RUnlock()
		stats["count"] = count
	}

	return stats
}

// GetRateLimitStats returns current rate limiting statistics
func (rl *RateLimiter) GetRateLimitStats() map[string]interface{} {
	ctx := context.Background()

	stats, err := rl.backend.GetStats(ctx)
	if err != nil {
		log.WithError(err).Error("Failed to get backend stats")
		return map[string]interface{}{
			"enabled": rl.config.Enabled,
			"error":   "Failed to get stats from backend",
		}
	}

	result := map[string]interface{}{
		"enabled":         rl.config.Enabled,
		"tracked_ips":     stats.TrackedIPs,
		"banned_ips":      stats.BannedIPs,
		"tor_banned_ips":  stats.TorBannedIPs,
		"backend_type":    stats.BackendType,
		"whitelist_count": len(rl.whitelists),
	}

	if stats.BackendInfo != nil {
		result["backend_info"] = stats.BackendInfo
	}

	return result
}

// GetBannedIPs returns a list of currently banned IPs
func (rl *RateLimiter) GetBannedIPs() []map[string]interface{} {
	ctx := context.Background()

	bannedIPs, err := rl.backend.GetAllBannedIPs(ctx)
	if err != nil {
		log.WithError(err).Error("Failed to get banned IPs")
		return []map[string]interface{}{}
	}

	var result []map[string]interface{}

	for _, ip := range bannedIPs {
		ban, err := rl.backend.GetBan(ctx, ip)
		if err != nil {
			log.WithError(err).WithField("ip", ip).Error("Failed to get ban details")
			continue
		}

		if ban != nil {
			result = append(result, map[string]interface{}{
				"ip":            ip,
				"banned_at":     ban.BannedAt,
				"expires_at":    ban.ExpiresAt,
				"reason":        ban.Reason,
				"is_tor_exit":   ban.IsTorExit,
				"offense_count": ban.OffenseCount,
			})
		}
	}

	return result
}
